use crate::ast::{Expr, Exprs};

grammar;

pub CairoParserOutput: Exprs = {
    StructName "()" => Exprs(Vec::new()),
    StructName "(" <n:Comma<Arg>> ")" => Exprs(n.iter().flat_map(|x| x.iter().cloned()).collect()),
};

FlatExpr: Vec<String> = {
    <n:Num> => vec![n],
    StructName "()" => Vec::new(),
    StructName "(" <n:Comma<FlatArg>> ")" => n.iter().flat_map(|x| x.iter().cloned()).collect(),
};

FlatArg: Vec<String> = {
    ArgName "=" <n:FlatExpr> => n,
};

Arg: Exprs = {
    ArgName "=" <n:Num> => Exprs(vec![Expr::Value(n)]),
    ArgName "=" "[" <n:Comma<FlatExpr>> "]" => Exprs(vec![Expr::Array(n.iter().flat_map(|x| x.iter().cloned()).collect())]),
    ArgName "=" <n:CairoParserOutput> => n,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

StructName: String = <s:r"[A-Z][A-Za-z]+"> => s.to_string();
ArgName: String = <s:r"[a-z_]+"> => s.to_string();
Num: String = <s:r"[0-9]+"> => s.to_string();
